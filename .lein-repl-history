(+ 1 1)
 (reduce and true [true])
(reduce and true [true])
(reduce && true [true])
(reduce + true)
(reduce + [0 1])
(reduce + 3 [0 1])
(reduce and true [true])
(reduce 'and true [true])
(reduce 'and true [false])
(reduce 'and true [false true])
(and true false true)
(and [true false true])
(every? identity [true  true false true])
(apply identity [true  true false true])
(apply (fn [& the-rest] the-rest) [true  true false true])
(apply (fn [& the-rest] the-rest) [true  true false true] [1 2 3])
(apply (fn [& the-rest] the-rest) [[true  true false true] [1 2 3]])
((fn [& the-rest] the-rest) [[true  true false true] [1 2 3]])
((fn [& the-rest] the-rest) [true  true false true] [1 2 3])
(apply (fn [& the-rest] the-rest) [true  true false true] [1 2 3])
(apply (fn [the-rest] the-rest) [true  true false true] [1 2 3])
(apply (fn [& the-rest] the-rest) [true  true false true] [1 2 3])
(apply (fn [& the-rest] the-rest) [true  true false true])
(reduce (fn [acc element] (and acc ele)) true [true  true false true])
(reduce (fn [acc element] (and acc element)) true [true  true false true])
(reduce (fn [acc element] (and acc element)) true [true  true true true])
(defn all-positive [& elements] (every? identity elements))
(all-positive [2 3])
(all-positive [0 1])
(all-positive [nil 1])
(all-positive [nil false])
(all-positive nil false)
(all-positive nil 0)
(all-positive nil 1)
(all-positive 2 1)
(all-positive 2 nil)
(defn all-true [elements] (reduce (fn [acc element] (and acc element)) true elements))
(all-true 1 2 3)
(defn all-true [& elements] (reduce (fn [acc element] (and acc element)) true elements))
(all-true 1 2 3)
(all-true 1 2 3 76)
(all-true 1 2 3 64)
(and 64 3)
(and 3 64)
(all-true true)
(all-true true false)
(all-true true false true)
(and 0 64)
(and 64 0)
(source and)
(source identity)
(source every?)
(source ->)
(apply every? true)
(apply every? [true])
(apply every? [true true])
(load "test/simple/polynomial")
(ns test)
(load "test/simple/polynomial")
(load-file "test/simple/polynomial")
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(map #((if (= :x %) x %)) [:x])
(def x 1)
(map #((if (= :x %) x %)) [:x])
(map #(if (= :x %) x %) [:x])
(map #(if (= :x %) x %) [:x 3])
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(eva [:x] 1)
(eva [:x] 2)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(eva [:x] 2)
(eva [:x] 1)
(= 1 (eva [:x] 1))
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(eva [:y] 1)
(eva [:y 2] 1)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(eva [:y] 1)
(number? 1)
(number? a)
(number? :a)
(number? "a")
(every number? ["a"])
(all number? ["a"])
(every? number? ["a"])
(every? number? [1 2 3])
(every? number? [1 2 3 :a])
(every? number? [1 2 3 :a 2])
(load-file "test/simple/polynomial.clj")
(facts)
(rest [0 1 2]
)
(load-file "test/simple/polynomial.clj")
(facts)
 (eva "0" 1)
(parse- "0" :x)
(load-file "test/simple/polynomial.clj")
(facts)
 (eva "0" 1)
(facts)
(load-file "test/simple/polynomial.clj")
 (eva "0" 1)
(facts)
(eva "x" 1)
(eva "y" 1)
(load-file "test/simple/polynomial.clj")
(facts)
(macroexpand '(when (pos? a) (println "positive") (/ b a)))
(macroexpand '(+ 1 2))
(eval (macroexpand '(+ 1 2)))
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(for [x [1 2 3]] x)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(merge {:a 1} {:c 2}}
(merge {:a 1} {:c 2})
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(:line :a)
(load-file "test/simple/polynomial.clj")
(facts)
(test-library-facts)
(->> [1 2 3] inc inc inc)
(def name "jb")
(load-file "test/simple/polynomial.clj")
(facts)
(->> 1 inc inc)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(source ->>)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(load-file "test/simple/polynomial.clj")
(facts)
(test-library-facts)
(source if-let)
(load-file "test/simple/polynomial.clj")
(exercise-macro)
(load-file "test/simple/polynomial.clj")
(exercise-macro)
(load-file "test/simple/polynomial.clj")
(code-critic (1 + 1) (+ 1 1))
(code-critic (1 + 1))
(code-critic (1 + 1) (1 + 1))
(load-file "test/simple/polynomial.clj")
(code-critic (1 + 1) (1 + 1))
(code-critic (1 + 1))
(code-critic {:good (+ 1 1) :bad (1 + 1)})
(load-file "test/simple/polynomial.clj")
(code-critic (+ 1 1) (1 + 1))
(load-file "test/simple/polynomial.clj")
(code-critic (+ 1 1) (1 + 1))
(load-file "test/simple/macro1.clj")
(code-critic (+ 1 1) (1 + 1))
