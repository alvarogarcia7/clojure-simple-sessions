(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
g d
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(evaluate (+ 1 1))
(load-file "test/simple/macro1.clj")
(map evaluate [])
(map and [])
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(test-library-facts)
(load-file "test/simple/macro1.clj")
(macroexpand (all-truthy? (= 1 2)))
(load-file "test/simple/macro1.clj")
(macroexpand (all-truthy? (= 1 2)))
(macroexpand (and 0 1)))
(macroexpand (and 0 1))
(macroexpand '(and 0 1))
(macroexpand '(all-truthy? (= 1 2)))
(macroexpand '((all-truthy?
    (= false true))
)
(macroexpand '(all-truthy? (= 1 2)))))
(macroexpand '(all-truthy? (= 1 2)))
(all-truthy? (= 1 2))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2))
(macroexpand '(all-truthy? (= 1 2)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2)))
(all-truthy? (= 1 2))
(all-truthy? (= 1 1))
(all-truthy? (= 1 1) (= 1 2))
(all-truthy? (= 1 3) (= 1 2))
(all-truthy? (= 1 1) (= 1 2))
(all-truthy? (= 1 1))
(all-truthy? (= 1 2) (= 1 1))
(test-library-facts)
(macroexpand '(all-truthy? (= 1 2)))
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(all-truthy? (= 1 2) (= 2 3))
(do (clojure.core/-> {:expression "p1__2081#", :value (= 1 2)} {:expression "p1__2081#", :value (= 2 3)}))
(do (-> {:expression "p1__2081#", :value (= 1 2)} {:expression "p1__2081#", :value (= 2 3)}))
(do (-> {:expression "p1__2081#", :value (= 1 2)}))
(-> {:expression "p1__2081#", :value (= 1 2)})
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(all-truthy? (= 1 2) (= 2 3))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 3))
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(all-truthy? (= 1 2) (= 2 3))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 3))
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 3))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 3))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 3))
(macroexpand '(all-truthy? (= 1 2) (= 2 3)))
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 3))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(source macroexpand)
(source macroexpand-1)
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 5))
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 5))
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 5))
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(load-file "test/simple/macro1.clj")
(macroexpand '(all-truthy? (= 1 2) (= 2 5)))
(all-truthy? (= 1 2) (= 2 5))
(load-file "test/simple/macro1.clj")
(all-truthy? (= 1 2) (= 2 5))
(run-tests 'simple.steganography)
(use 'midje.repl)
(autotest)
*me
(use 'midje.repl)
(autotest)
(use 'midje.repl)
(autotest)
(rand-nth 34)
rand-nth
(source rand-nth)
(rand-int 10)
(take 40 (repeat #(rand-int 10)))
(take 40 (cycle #(rand-int 10)))
(take 40 (repeat (rand-int 10)))
(take 40 (repeat '(rand-int 10)))
(take 40 (cycle (defn [] (rand-int 10))))
(take 40 (cycle (fn [] (rand-int 10))))
(take 40 (repeat (fn [] (rand-int 10))))
(doall (take 40 (repeat (fn [] (rand-int 10)))))
(take 40 (repeat (fn [] (rand-int 10))))
(repeat (fn [] (rand-int 10)))
(fn [] (rand-int 10))
((fn [] (rand-int 10)))
(defn r [] (rand-int 10))
(take 40 (repeat r))
(map identity (take 40 (repeat r)))
(map eval (take 40 (repeat r)))
(map -> (take 40 (repeat r)))
(take 40 (repeat r))
(take 40 (repeatedly r))
(frequencies (take 40 (repeatedly r)))
(frequencies (take 40000 (repeatedly r)))
(frequencies (take 400000 (repeatedly r)))
(frequencies (take 4000000 (repeatedly r)))
(def s1 (frequencies (take 4000000 (repeatedly r))))
s1
(max (map second s1))
(apply max (map second s1))
(apply #(-> (max %) (min %)) (map second s1))
(-> [(apply max)] (map second s1))
(apply max (map second s1))
(apply min (map second s1))
(- 400957 398412)
(/ (- 400957 398412) 2545)
(/ (- 400957 398412) 2545M)
(/ (- 400957 398412) 4000000M)
(* 100 (/ (- 400957 398412) 4000000M))
(* 1000 (/ (- 400957 398412) 4000000M))
(* 10000 (/ (- 400957 398412) 4000000M))
(rand-int 0)
(rand-int -1)
(source comp)
(conceal-message "///")
(ns simple.steganography)
(conceal-message "///")
(def n 6)
(def problem "https://www.hackerrank.com/challenges/staircase")
(range 1 n)
(range 1 (inc n))
(- n 3)
(take 3 (repeat " ")
)
(str (take 3 (repeat " ")))
(doall (str (take 3 (repeat " "))))
(source join)
(source clojure.string/join)
(clojure.string/join (take 3 (repeat " ")))
(clojure.string/join (take 3 (repeat "#")))
(clojure.string/join (take 3 (repeat "#")) (take 3 (repeat " ")))
(clojure.string/join (concat (take 3 (repeat "#")) (take 3 (repeat " "))))
(clojure.string/join (concat (take 3 (repeat " ")) (take 3 (repeat "#"))))
(defn line [total n]
(let [padding (- total n)])
(clojure.string/join (concat (take padding (repeat " ")) (take n (repeat "#")))))
(->> (range 1 (inc n)
(line n)
(defn line [total n]
(let [padding (- total n)]
(clojure.string/join (concat (take padding (repeat " ")) (take n (repeat "#"))))))
(->> (range 1 (inc n)
(line n)
)
(->> (range 1 (inc n))
(line n)
)
(->> (range 1 (inc n))
(map #(line n))
)
(->> (range 1 (inc n))
(map #(line n %))
)
(->> (range 1 (inc n))
(map #(line n %))
println
)
(->> (range 1 (inc n))
(map #(line n %))
(map println)
)
(defn line [total n]
(let [padding (- total n)]
(clojure.string/join (concat (take padding (repeat ".")) (take n (repeat "#"))))))
(->> (range 1 (inc n))
(map #(line n %))
(map println)
)
(range 7)
(range 1 7)
(defn stairs
 [n]
(->> 
(range 1 (inc n))
(map #(line n %))
(map println)))
(stairs 6)
(defn line [total n]
(let [padding (- total n)]
(clojure.string/join (concat (take padding (repeat ".")) (take n (repeat "#"))))))
(defn stairs
 [n]
(->> 
(range 1 (inc n))
(map #(line n %))
(map println)))
(stairs 6)
(read-line)
(Integer/parseInt (read-line))
(defn stairs
 [n]
(->> 
(range 1 (inc n))
(map #(line n %))
))
(stairs 2)
(instance? String "a")
(source doseq)
(instance? String (stairs 6))
(instance? LazySeq (stairs 6))
(instance? clojure.lang.LazySeq (stairs 6))
(doall identity clojure.lang.LazySeq (stairs 6))
(doall identity (stairs 6))
(doall (stairs 6))
(instance? clojure.lang.LazySeq (doall (stairs 6)))
(for [a (range 1 10)] a)
(for [a (range 1 10)] (inc a))
(for [index (range n)] (get-in matrix [index index]))
(def matrix (list '(11 2 4) '(4 5 6) '(10 8 -12)))
matrix
(for [index (range n)] (get-in matrix [index index]))
(def n 3)
(for [index (range n)] (get-in matrix [index index]))
(source get-in)
(get-in matrix [1])
(-> matrix [1])
(-> matrix 1)
(-> matrix (nth 1))
(-> matrix (nth 1) (nth 1))
(for [index (range n)] (let [] (list index index)))
(for [index (range n)] (let [x index y] (list x y)))
(for [index (range n)] (let [x index y 1] (list x y)))
(for [index (range n)] (let [x index y (- n x)] (list x y)))
(for [index (range n)] (let [x index y (- (dec n) x)] (list x y)))
(abs -1)
(Math/abs
-1)
(source get-in)
(def input (list 1 0 -3))
(reduce {:positive 0 :negative 0 :zero 0} identity)
(reduce {:positive 0 :negative 0 :zero 0} identity input)
(reduce {:positive 0 :negative 0 :zero 0} #(-> %2) input)
(reduce {:positive 0 :negative 0 :zero 0} #(-> %1) input)
(reduce #(-> %2) {:positive 0 :negative 0 :zero 0} input)
(reduce #(-> %1) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [a _] %1) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [a _] a) {:positive 0 :negative 0 :zero 0} input)
(source frequencies)
(assoc  {:positive 0 :negative 0 :zero 0} :positive 1)
(reduce (fn [x acc] (cond (< x 0) (assoc acc (inc (:negative acc))))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [x acc] (cond (< x 0) (assoc acc :negative (inc (:negative acc))))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [x acc] (cond (< x 0) (inc (:negative acc)))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [x acc] (inc (:negative acc))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (inc (:negative acc))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] acc) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (inc (:negative acc)) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (inc (:negative acc))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (:negative acc)) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] acc) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (assoc acc :negative 1)) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (assoc acc :negative (:negative acc))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (assoc acc :negative (inc (:negative acc)))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (cond (< x 0) (assoc acc :negative (inc (:negative acc))) :else (assoc acc :positive (inc (:positive acc))))) {:positive 0 :negative 0 :zero 0} input)
(reduce (fn [acc x] (cond (< x 0) (assoc acc :negative (inc (:negative acc)))  (= x 0) (assoc acc :zero (inc (:zero acc))) :else (assoc acc :positive (inc (:positive acc))))) {:positive 0 :negative 0 :zero 0} input)
(defn- group-by-sign
[acc x]
(cond 
 (< x 0) (assoc acc :negative (inc (:negative acc)))
 (= x 0) (assoc acc :zero (inc (:zero acc))) 
 :else (assoc acc :positive (inc (:positive acc)))))
(defn- grouped
[input]
(reduce group-by-sign {:positive 0 :negative 0 :zero 0} input))
(grouped input)
(keys (grouped input))
(+ (values (grouped input)))
(+ (vals (grouped input)))
(reduce + (vals (grouped input)))
(def percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(map #(-> {% (/ % total)}) frequency)))
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(map #(-> {% (/ % total)}) frequency)))
(percentages input)
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(map #(-> {% (/ %2 total)}) frequency)))
(percentages input)
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(map (fn [[k v]] {k (/ v total)}) frequency)))
(percentages input)
(println 1/3)
(println 1/3.)
(println (double 1/3))
(defn- obtain-percentages
[input]
(let [percentages (percentages input)])
(println (:positive percentages))
(println (:negative percentages))
(println (:zero percentages)))
(obtain-percentages input)
(percentages input)
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] k (double (/ v total))}) frequency))))
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] k (double (/ v total))}) frequency))))
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] k (double (/ v total))}) frequency))))
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(map (fn [[k v]] k (double (/ v total))}) frequency)))
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] k (double (/ v total))) frequency))))
(percentages input)
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] {k (double (/ v total))}) frequency))))
(percentages input)
(obtain-percentages input)
(defn- percentages 
[input]
(let [frequency (grouped input)
total (reduce + (vals frequency))]
(into {} (map (fn [[k v]] {k (double (/ v total))}) frequency))))
(defn- obtain-percentages
[input]
(let [percentages- (percentages input)])
(println (:positive percentages-))
(println (:negative percentages-))
(println (:zero percentages-)))
(defn- obtain-percentages
[input]
(let [percentages- (percentages input)]
(println (:positive percentages-))
(println (:negative percentages-))
(println (:zero percentages-))))
(obtain-percentages input)
(def time "07:05:45PM")
tiem
time
(contains? "PM" time)
(.indexOf "PM" time)
(.indexOf time "PM")
(clojure.string/split time ":")
(clojure.string/split time #":")
(clojure.string/replace "[A|P]M" "" time)
(clojure.string/replace time "[A|P]M" "")
(source clojure.string/replace)
(clojure.string/replace time "[A|P]M" "")
(clojure.string/replace time "[A|P]" "")
(clojure.string/replace time "[AP]" "")
(clojure.string/replace time #"[AP]" "")
(clojure.string/replace time #"[AP]M" "")
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") (+ 12 hour))  hour)]
       (println (str hour ":" minute ":" second}})))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") (+ 12 hour))  hour)]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") (+ 12 (Integer/parseInt hour))  hour)]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") (+ 12 (Integer/parseInt hour))  hour))]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") (+ 12 (Integer/parseInt hour)))  hour)]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") 0) (+ 12 (Integer/parseInt hour)))  hour)]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (if (> (.indexOf time "PM") 0) (+ 12 (Integer/parseInt hour)) hour )]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (Integer/parseInt hour)
       hour (cond 
        (> (.indexOf time "PM") 0) (+ 12 hour) 
        (< hour 10) (str 0 hour)]
       (println (str hour ":" minute ":" second)))
(let [[hour minute second] (clojure.string/split (clojure.string/replace time #"[AP]M" "")  #":" )
       hour (Integer/parseInt hour)
       hour (cond 
        (> (.indexOf time "PM") 0) (+ 12 hour) 
        (< hour 10) (str 0 hour))]
       (println (str hour ":" minute ":" second)))
(def time "07:05:45AM")
